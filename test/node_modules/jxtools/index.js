// Copyright & License details are available under JXCORE_LICENSE file


var fs = require('fs');
var path = require("path");

exports.assert = require("./assert.js");

// true when app is stared with mt/mt-keep
exports.mted = false;
exports.mtkeeped = false;

for (var o in process.argv) {
  if (process.argv[o].slice(0, 7) == "mt-keep")
    exports.mtkeeped = true;

  if (process.argv[o].slice(0, 2) == "mt")
    exports.mted = true;
}

exports.rmdirSync = function (fullDir) {

  fullDir = path.normalize(fullDir);
  if (!fs.existsSync(fullDir)) {
    return;
  }

  var cmd = process.platform === 'win32' ? "rmdir /s /q " : "rm -rf ";
  jxcore.utils.cmdSync(cmd + fullDir);
};


exports.copyFileSync = function (src, dest) {

  src = path.normalize(src);
  dest = path.normalize(dest);
  if (!fs.existsSync(src)) {
    return;
  }

  fs.writeFileSync(dest, fs.readFileSync(src));
};


/**
 * If src is a file, than copies it to dest.
 * If src is a folder, than copies it to dest recursively.
 * @param src
 * @param dest
 */
exports.copySync = function (src, dest) {

  src = path.normalize(src);
  dest = path.normalize(dest);
  if (!fs.existsSync(src)) {
    return;
  }

  var stats = fs.statSync(src);
  if (stats.isFile()) {
//        console.log("Copying file to " + dest);
    fs.writeFileSync(dest, fs.readFileSync(src));
    return;
  }

  if (stats.isDirectory()) {
//        console.log("Copying folder to " + dest);
    var files = fs.readdirSync(src);

    if (!files.length) {
      return;
    }

    if (!fs.existsSync(dest)) {
      fs.mkdirSync(dest);
    }

    for (var a in files) {
      var srcFile = src + path.sep + files[a];
      var dstFile = dest + path.sep + files[a];
      var stats = fs.statSync(srcFile);

      if (stats.isDirectory()) {
        exports.copySync(srcFile, dstFile);
      } else {
        fs.writeFileSync(dstFile, fs.readFileSync(srcFile));
      }
    }
  }
};


/**
 * Useful for app with tasks. Main process needs time to exit when a task was added (even if it was finished).
 * So we can try to force faster exit, just for faster tests processing.
 */
exports.exitNow = function () {

  return;
  if (process.threadId === -1) {
    // main thread;
    //process.exit();
    setTimeout(process.exit, 10);
    return;
  }
};


/**
 * mt/mt-keep exits are slow, so we can try to force faster exit, just for faster tests processing.
 * But still we exit ONLY when all of the other threads already called it.
 * BEWARE, process.on('exit') may not be called for all threads, so don't use the method below if you rely on process.on('exit').
 *
 * You can safely disable this method by calling return at the beginning.
 */
exports.exitNowMT = function () {

  return;
  //console.log("mted", exports.mted);
  if (!exports.mted) return;

  jxcore.store.shared.set("mtkeep-thread" + process.threadId, "ok");

  var all = true;
  for (var a = 0; a < jxcore.tasks.getThreadCount(); a++) {
    if (!jxcore.store.shared.exists("mtkeep-thread" + a)) {
      all = false;
      break;
    }
  }

  if (all) {
    //console.log("All threads done. Exiting");
    process.exit();
  }
};


/**
 * Instead of throwing error writes it into console and exist with exitCode = -1
 * This is mostly for mt app, which restart the thread on throw instead of exit the test.
 * @param err
 */
exports.throwMT = function (err) {

  if (process.threadId == -1) {
    throw err;
    return;
  }

  if (err) {
    console.error("throwMT:");
    console.error("\t", err);
  }

  process.exit(-1);
};