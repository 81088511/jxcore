{
  "source": "doc/api/jxcore-feature-internal-recovery.markdown",
  "modules": [
    {
      "textRaw": "Internal Recovery",
      "name": "internal_recovery",
      "desc": "<p>In addition to recovering of crashed applications&#39; processes by external <a href=\"jxcore-command-monitor.html\">monitoring process</a>,\nJXcore also provides automatic Internal Process Recovery as well as Internal Thread Recovery (for code running in multithreaded mode).\n\n</p>\n",
      "modules": [
        {
          "textRaw": "Internal Process Recovery",
          "name": "internal_process_recovery",
          "desc": "<p>Attaching any callback to <code>restart</code> event <strong>inside a main thread</strong> enables Internal Process Recovery.\nWhen an exception occurs inside the application, the callback is invoked and there you may decide if to allow restart of the entire process or not.\nAlso this is a good opportunity to save some data used by the application, because after it will crash, normally they would be lost.\n\n</p>\n<pre><code class=\"js\">process.on(&#39;restart&#39;, function (restartCallback, newExitCode) {\n    // do whatever you want before application&#39;s crash\n    // and when you&#39;re done - call the callback to restart the process\n    restartCallback();\n});</code></pre>\n<p>Arguments for the callback:\n\n</p>\n<ul>\n<li><code>restartCallback</code> {Function}<ul>\n<li><code>newExitCode</code> {Number}</li>\n</ul>\n</li>\n<li><code>currentExitCode</code> {Number}</li>\n</ul>\n<p>The <code>restartCallback</code> is a function, which should be invoked if you want to allow for application restart/recovery.\nIf you will not call it, the process will exit (after all it has just crashed) but not restart.\n\n</p>\n<p>Any tasks, that you want to perform, like saving some application&#39;s data (objects, variables etc) into database, must be done before calling <code>restartCallback</code>.\n\n</p>\n<p>When invoking this callback, you can pass an <code>newExitCode</code>, that you want the application&#39;s process to be restarted with:\nthe current process will exit with this code and after that the application will be relaunched as a new process.\n<code>newExitCode</code> for the callback is optional. When omitted, the current application&#39;s exit code will be used.\n\n</p>\n<p><code>currentExitCode</code> - holds current exit code of the application, which is just about to crash.\n\n</p>\n<p>In the example below we are throwing an exception, which causes <code>restart</code> event to be fired. Just before the restart, we&#39;re adding new parameter to <code>process.argv</code>, and this is the way to pass an argument to the new process.\nWe do this in order to prevent circular recoveries.\n\n</p>\n<p>The code should be launched as single threaded (without mt/mt-keep parameter), because it handles recovery of the main process:\n\n</p>\n<pre><code>&gt; jx sample.js</code></pre>\n<p>sample.js:\n\n</p>\n<pre><code class=\"js\">process.on(&#39;restart&#39;, function (restartCallback, newExitCode) {\n\n    //in order to prevent circular recoveries only recover once!\n    if (process.argv[process.argv.length - 1] != &quot;111&quot;) {\n        process.argv[process.argv.length] = 111;\n\n        console.log(&quot;Restarting&quot;);\n        //calling restartCB\n        restartCallback(123);\n    }\n    else {\n        // we&#39;re not calling restartCallback(), so the application will exit\n        // without restarting\n        console.log(&quot;Skipping restart.&quot;);\n    }\n});\n\n\n// JXcore does not autorestart application if it dies under 5000 ms\nsetTimeout(function () {\n    throw &quot;&quot;;\n}, 5200);</code></pre>\n<p>There are two situations, when Internal Process Recovery is not performed:\n\n</p>\n<ol>\n<li>application was alive less than 5000 milliseconds. This value will be configurable, but for now it&#39;s a constant.</li>\n<li>when any listener is attached to <code>process.on(&quot;uncaughtException&quot;)</code> event, the thread recovery is not active,\nbecause it makes sense only for uncaught exceptions, which in this case are actually caught by <code>uncaughtException</code> event.</li>\n</ol>\n",
          "type": "module",
          "displayName": "Internal Process Recovery"
        },
        {
          "textRaw": "Internal Thread Recovery",
          "name": "internal_thread_recovery",
          "desc": "<p>This is analogous to <a href=\"#internal_process_recovery\">Internal Process Recovery</a>, except that it concerns a <strong>single thread</strong> rather than entire application&#39;s process.\n\n</p>\n<p>Attaching any callback to this event inside a code running in a subthread enables internal thread recovery.\nWhen an exception occurs inside the subthread, the callback is invoked and there you may decide if to allow restart of the thread or not.\nAlso this is a good opportunity to save some data used by this thread, because after it will crash, normally they would be lost.\n\n</p>\n<pre><code class=\"js\">process.on(&#39;restart&#39;, function (restartCallback) {\n    // do whatever you want before thread&#39;s crash\n    // and when you&#39;re done - call the callback to restart the thread\n    restartCallback();\n});</code></pre>\n<p>Argument for the callback:\n\n</p>\n<ul>\n<li><code>restartCallback</code> {Function}</li>\n</ul>\n<p>This is a function, which should be invoked if you want to allow for thread recovery. If you will not call it, the thread will die but not restart.\nAny tasks, that you want to perform, like saving some thread&#39;s data (objects, variables etc) into database or even shared memory store, must be done before calling <code>restartCallback</code>.\n\n</p>\n<p>In the example below we are throwing an exception, which causes <code>restart</code> event to be fired. Also we are counting how many times thread was restarted, and based on that we decide if to allow for another restart or not.\n\n</p>\n<p>The code should be run with mt-keep parameter:\n\n</p>\n<pre><code>&gt; jx mt-keep sample.js</code></pre>\n<p>sample.js:\n\n</p>\n<pre><code class=\"js\">var shared = jxcore.store.shared;\nvar sid = &quot;threadRestartCount_&quot; + process.threadId;\n\nvar counter = 0;\n\n// this is just for storing thread&#39;s restart counter.\n// we use jxcore.store.shared here, because it is static (unrelated to the threads)\nif (shared.exists(sid)) {\n    counter = parseInt(shared.get(sid)) + 1;\n    console.log(&quot;Thread no %s restarted %d times.&quot;, process.threadId, counter);\n}\nshared.set(sid, counter);\n\n// attaching callback to this event enables the thread recovery,\n// but still you need to call restartCallback() explicitly to make a restart\nprocess.on(&#39;restart&#39;, function (restartCallback) {\n    if (counter &lt; 3) {\n        // we don&#39;t want to allow for infinitive restarts. 3 is enough.\n        console.log(&quot;Restarting thread no &quot; + process.threadId);\n        restartCallback();\n    } else {\n        console.log(&quot;Thread no %s was restarted %d times. We&#39;ll not restart any more.&quot;,\n            process.threadId, counter);\n        // releasing the thread allows main process to exit,\n        // when all the threads are released.\n        process.release();\n    }\n});\n\n// this loop is used to throw an exception inside a subthread\nsetTimeout(function () {\n    throw &quot;Let&#39;s restart the thread!&quot;;\n}, 100 * counter * process.threadId);</code></pre>\n<p>Please note, that when any listener is attached to <code>process.on(&quot;uncaughtException&quot;)</code> event, the thread recovery is not active, because it makes sense only for uncaught exceptions, which in this case are actually caught by <code>uncaughtException</code> event.\n\n</p>\n",
          "type": "module",
          "displayName": "Internal Thread Recovery"
        }
      ],
      "type": "module",
      "displayName": "Internal Recovery"
    },
    {
      "textRaw": "Internal Recovery vs Process Monitor",
      "name": "internal_recovery_vs_process_monitor",
      "desc": "<p>Process Monitor and Internal Process Recovery should not be used simultaneously. Both of them perform restart of the application&#39;s process,\nso they could interfere with each other leading to unexpected behaviour. For example, the application could be respawned into multiple instances, or fall into uncontrolled loop of restarting.\n\n</p>\n<p>On the other hand, when your application is running in multithreaded mode, you can still use Internal Thread Recovery\n(which allows to restart crashed threads, not the application&#39;s process) together with Process Monitor.\n</p>\n",
      "type": "module",
      "displayName": "Internal Recovery vs Process Monitor"
    }
  ]
}
